        	+---------------------------+
		    | CS 140                    |
		    | PROJECT 3: VIRTUAL MEMORY	|
		    |	DESIGN DOCUMENT         |
		    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Kefei Wu <wukf@shanghaitech.edu.cn>
Ziyang Wang <wangzy4@shanghaitech.edu.cn>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

None.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

Help from the another group about the theory about spt's application truly 
assist us.



			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct page {
  void* addr;               # page virtual address
  struct frame* frame;      # its corresponding frame struct
  struct thread* t;		    # its held thread struct
  bool read_only;			# whether read only
  struct file* file;		# the file struct it contains
  int offset;				# Values of offsets.
  int rw_bytes;				# read and write bytes size
  block_sector_t swap;		# Index of a block device sector
  bool mmap;				# whether or not mmap
  struct hash_elem elem;  	# elems stores in hash table
};

struct frame 
  {
	struct page* page;		# record page position pointer
	void* addr;				# the data physical memory
	struct list_elem elem;	# the data with the list form
	struct lock lock;		# the lock to ensure no collision
  };



---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for accessing the data
>> stored in the SPT about a given page.

If data is stored in SPT, it can be found directly with its virtual memory position given with the page and all page's information could be reached.

Or according to the page structure I provide above, the corresponding frame structure pointer should be associated and through which we can find the data with physical memory position. If the frame seems to be NULL, which means it hasn't been allocated yet, which means the page we look for is not in physical memory now.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

By accessing the user virtual memory as more as possible, and kernel as fewer as possible, including the situation where page fault should be handled, avoid accessing it from the kernel virtual memory in user pool.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

With help of scan_lock, everytime we search for and create a new frame should be arranged to a process a time and there will be no situations where two processes work together. And the lock in frame structure will ensure the race won't happen too.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

Hash table that the Pintos provides already, whose space and time complexity when facing searching and inserting is better than normal list, which will help search for the virtual memory and speed up the virtual-to-physical mappings. And with the elems in frame and page structures, such as each other's corresponding address, the search could be more directly and convinient.


		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct page and struct frame referred above.

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

LRU evicting strategy.

Discards the least recently used items first.

In our complemention, if free frame exist, use it.

If not, search for the first time for the accessed recently page and turn it to not-accessed ones by turning their access bit to 0 and in the second round use the page-outed place and release the lock.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

In page_out() function we call pagedir_clear_page() function, which means we clear the whole entry, change its status and determine whether to swap it out according to it's dirty and private or not. After this step, the physical space will be clean for the coming process P and Q may be recorded with another way in disks and SPT with all its information.

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

Its validation should be evaluated firstly, to detect if it's between user memory start and top of the process stack to ensure it attempts to read something it should not reach and according to PUSHA instructions to check the thread's pointer down to 32 bytes and finally to use allocate function to extend the stack.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

The whole system will not meet the situation with deadlock with help of two functions, one of it is try_acquire() function (in which lock will not be acquired if locked already) and the operation lock in searching or evicting, with which we will ensure that no circular dependency. And any attempts to modify and replace it has been discussed in the following problems.

One situation i thought when one process hold the corresponding page entry while the other one try to getmap() (which will funct like getfile with mmap methods) but it seems to not happen too with try_acquire() function.

In conclusion, no deadlocks will be acquired in the project.

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

Before P evicts Q's frame, it should make sure there're no more locks in Q's frame and it can be evicted and when it starts, P's lock will prevent from other processes trying to operate on it, including interupt the process of evicting Q's frame and write P's, after which completes Q's frame will turn to be NULL which means it can't be modified by Q again unless Q try to swap P's frame out.

And by using a lock and LRU strategy (which lock will be released on) makes sure that only one process will be called at the same time, which seems will avoid race effienctly.

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

The lock in frame structure will ensure the operation to be done before other operations attempt to change its value while it's still being read in.

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

Attempts to access to a page-outed page will incur to page fault, which will contribute to its searching for its information before being page-outed. If existed, evict pages to get it in again with LRU strategy to evict and swap function to swap in or confirm that it doesn't exist in SPT and open and page-in it.

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

We use more than one lock to ensure the parallelism but every type of variables better keep only one lock to make the code easier to understand and less possible to generate deadlock.

For different kinds of operations like searching or paging-out, they have different locks to make sure the whole precess will be ended correctly, in which way the whole system's operation will keep atomic when handling a single frame or file (which has its own lock designed in proj 2 too), and pte may help record the information and keep every frame clear too.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct mapping
{
  int id;				# mmap id
  struct file* file;	# the file associated with the page
  uint8_t * addr;		# virtual page associated with a file
  int num;				# The number it called in mmap, or pages read in
  struct list_elem elem;# list_elem stored in a process
};

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

For each process, a hash table will be created to contain file's content with pages and return a mmap id to record the concrete position, and munmap will help release the mapped memory one by one, if they are recorded as dirty, they should be writen back to the disk memory, and free all space finally.

When it refers to a mapped page to be evicted, as same as above steps, and it shall write back rather than swap to new location in disk.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

After we implement our supplemental page table we could check entrys of it to ensure that it was not recorded before, or return a null pointer if it overlaps existing segment, which will try to write pages in location where there already be pages.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

Large part of two kinds of situations handling, for the  differences between them is to decide whether to write the data back to the physical space. So in our implemention they share most of the function and the judgement about whether the private (False to write back to file, true to write back to swap.) is true, for write most of two diff situations in a function may be easier to understand and implement.


			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

Yes, very long time. Waste a lot of time to understand frameworks of vm and how to connect it with the syscall and process part we wrote before.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

vm.

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

More clear requirments may qualify the task.

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

More clearly on implemention structure in class.

>> Any other comments?

No more.
